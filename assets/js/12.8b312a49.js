(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{434:function(t,e,r){"use strict";r.r(e);var s=r(65),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"发布-订阅模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式"}},[t._v("#")]),t._v(" 发布/订阅模式")]),t._v(" "),r("p",[r("strong",[t._v("该模式包含三个模块 发布者-处理中心-订阅者")])]),t._v(" "),r("h2",{attrs:{id:"观察者模式与发布-订阅模式的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式与发布-订阅模式的区别"}},[t._v("#")]),t._v(" 观察者模式与发布/订阅模式的区别")]),t._v(" "),r("ul",[r("li",[t._v("观察者模式中，oberver和subject互相耦合，观察者知道目标，目标也保持着对观察者的记录。但发布/订阅模式中，发布者和订阅者都不知道对方的存在，只能通过处理中心进行通信，耦合度小")]),t._v(" "),r("li",[t._v("观察者大多数同步的，而发布/订阅大多数异步的（消息队列）")]),t._v(" "),r("li",[t._v("以DOM事件来说，有一个按钮B绑定了一个点击事件，这个事件的功能时弹出一个弹框，浏览器A会监听用户的点击动作。这个时候观察者模式和发布/订阅模式就有区别了，如果是观察模式的话，浏览器就会直接的告诉按钮B要触发一个弹出弹窗的方法。但如果是发布/订阅模式的话，浏览器只会通知一个公共的事件中心，说我监听到了一个点击事件，然后事件中心在下派给按钮B，告诉按钮B触发了点击事件。按钮B就会根据触发的事件做对应的操作，比如说点击事件就是弹出弹窗。这个时候A和B就不再有耦合关系，他们只会通过事件中心去做通信。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);