(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{450:function(t,s,a){"use strict";a.r(s);var n=a(65),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"一句话知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一句话知识"}},[t._v("#")]),t._v(" 一句话知识")]),t._v(" "),a("h2",{attrs:{id:"堆和栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈"}},[t._v("#")]),t._v(" 堆和栈")]),t._v(" "),a("p",[t._v("栈(stack): 栈会自动分配内存空间，会自动释放，存放"),a("strong",[t._v("基本类型")]),t._v("，简单的数据段，占据固定大小的空间。")]),t._v(" "),a("p",[t._v("堆(heap): 动态分配的内存，大小不定也不会自动释放，存放"),a("strong",[t._v("引用类型")]),t._v("，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。")]),t._v(" "),a("h2",{attrs:{id:"判断数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型"}},[t._v("#")]),t._v(" 判断数据类型")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("typeof")])])]),t._v(" "),a("p",[t._v("缺点")]),t._v(" "),a("ul",[a("li",[t._v("对于基本类型，除 null 以外，均可以返回正确的结果。")]),t._v(" "),a("li",[t._v("对于引用类型，除 function 以外，一律返回 object 类型。")]),t._v(" "),a("li",[t._v("对于 null ，返回 object 类型。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("instanceof")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\na "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[t._v("constructor")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" String "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" Array "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[a("strong",[t._v("借用Object的原型方法toString")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object String]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Number]")]),t._v("\n")])])]),a("h2",{attrs:{id:"事件循环-eventloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环-eventloop"}},[t._v("#")]),t._v(" 事件循环 EventLoop")]),t._v(" "),a("blockquote",[a("p",[t._v("当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 "),a("strong",[t._v("而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。")])])]),t._v(" "),a("ol",[a("li",[t._v("执行一个宏任务（栈中没有就从事件队列中获取）")]),t._v(" "),a("li",[t._v("执行过程中如果遇到微任务，就将它添加到微任务的任务队列中；")]),t._v(" "),a("li",[t._v("宏任务执行完毕后，"),a("strong",[t._v("立即执行当前微任务队列的所有微任务")]),t._v("；")]),t._v(" "),a("li",[t._v("当前微任务执行完毕，开始检查渲染，然后GUI线程接管渲染；")]),t._v(" "),a("li",[t._v("渲染完毕后，JS线程继续接管，开始下一个宏任务。")])]),t._v(" "),a("ul",[a("li",[t._v("微任务: promise.then")]),t._v(" "),a("li",[t._v("宏任务: ajax、定时器、一些浏览器api、script")])]),t._v(" "),a("h2",{attrs:{id:"为什么需要两种事件队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要两种事件队列"}},[t._v("#")]),t._v(" 为什么需要两种事件队列")]),t._v(" "),a("p",[a("strong",[t._v("为了插队")])]),t._v(" "),a("p",[t._v("一个事件循环，微任务是在宏任务之后调用，微任务会在下一个事件循环之前执行调用完，并且其中会将 微任务执行当中新注册的微任务一并调用执行完，然后才开始下一次事件循环，所以如果有新的宏任务就需要一直等待，等到上一个事件循环当中 微任务被清空为止。由此可见，我们可以在下一次事件循环之前进行插队。")]),t._v(" "),a("p",[a("strong",[t._v("如果不区分微任务和宏任务，那就无法在下一次事件循环之前进行插队，其中新注册的任务得等到下一个宏任务完成之后才能进行，这中间可能你需要的状态就无法在下一个宏任务中得到同步。")])]),t._v(" "),a("p",[t._v("状态的同步对于视图来说至关重要，这也就牵扯到了为什么 javascript 是单线程的原因所在。")])])}),[],!1,null,null,null);s.default=r.exports}}]);