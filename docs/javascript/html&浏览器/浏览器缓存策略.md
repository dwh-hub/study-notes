# 浏览器缓存策略

> http://verymuch.site/2018/10/09/web-browser-cache-strategy

## 一、缓存的判断策略

浏览器对于所请求资源的缓存处理有一套完整的机制，主要包含以下三个策略：**存储策略、过期策略、协商策略。**

- 过期策略: 发生在请求前，用于判断缓存是否过期。
- 协商策略: 发生在请求中，用于判断缓存资源是否更新。
- 存储策略: 发生在收到请求响应后，用于决定是否缓存相应资源。

![缓存流程](http://p3.qhimg.com/t01ce32ad8eab945a87.png)

## 二、缓存基础

HTTP中与缓存有关的字段主要有以下10个，如下表所示。为明确表示其功能及用法，下表中分别区分了存储策略、过期策略、协商策略、请求头、响应头。

| key    | 描述 | 存储策略 | 过期策略 | 协商策略 | 请求头 | 响应头 |
| :----: | --- | :----: | :----: | :----: | :----: | :----: |
| Expires | 指定缓存的过期时间，值为某一时刻（绝对时间）。在指定时刻后过期 | ✓ | ✓ |  |  | ✓ |
| Cache-Control | 指定缓存机制 | ✓ | ✓ |  | ✓ | ✓ |
| Pragma | 指定缓存机制(http1.0字段) |  |  |  | ✓ |  |
| Last-Modified | 资源最后修改时间 |  |  | ✓ |  | ✓ |
| If-Modified-Since | 指定缓存的过期时间，值为某一时刻（绝对时间）。在指定时刻后过期 |  |  | ✓ | ✓ |  |
| If-Unmodified-Since | 指定缓存的过期时间，值为某一时刻（绝对时间）。在指定时刻后过期 |  |  | ✓ | ✓ |  |
| ETag | 指定缓存的过期时间，值为某一时刻（绝对时间）。在指定时刻后过期 |  |  | ✓ |  | ✓ |
| If-Match | 指定缓存的过期时间，值为某一时刻（绝对时间）。在指定时刻后过期 |  |  | ✓ | ✓ |  |
| If-None-Match | 缓存协商校验字段，请求资源的唯一标识字符串，为上次请求收到的ETag的值。处理方式与If-Match相反。 |  |  | ✓ | ✓ |  |

## 三、缓存的优缺点

| key    | 优点 | 缺点 |
| :----: | --- | --- |
| Expires | 1. HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用。<br>2. 简单易用，通过绝对时间标识失效时间。 | 1. 时间为服务器返回的时间，如果本地时间与服务器时间不一致，则可能会出现问题。（如上述我们通过修改本地时间是缓存失效。）<br>2. 存在版本问题，在资源过期之前如果对资源进行修改，客户端都是无法获知的。 |
| Cache-Control | 1. HTTP 1.1的内容，以相对时间标识失效时间，解决了Expires服务器和客户端相对时间的问题。<br>2. 支持的指令较多，可以根据需要进行相应的配置。 | 1. HTTP 1.1 才有的内容，不适用于HTTP 1.0 。<br>2. 与Expires类似，存在版本问题，在资源过期之前如果对资源进行修改，客户端都是无法获知的。 |
| Last-Modified | 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。 | 1. 以时刻作为标识，精确到秒，无法识别一秒内进行多次修改的情况。<br>2. 只要资源被修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。 |
| ETag | 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。<br>2. 可以更加精确的判断资源是否被修改。<br>3. 可以识别一秒内多次修改的情况。 | 1. 计算ETag值会对性能造成一定消耗。<br>2. 分布式服务器存储的情况下，需要保证计算ETag的算法一致。如果不一致，会导致资源在不同服务器上验证不通过。 |

## 四、最佳实践

从上面各类缓存的优缺点可以看出，每一种缓存都不是完美的。所以建议像下面这样做：

1. 不要缓存HTML，避免缓存后用户无法及时获取到更新内容。
2. 使用Cache-Control和ETag来控制HTML中所使用的静态资源的缓存。一般是将Cache-Control的max-age设成一个比较大的值，然后用ETag进行验证。
3. 使用签名或者版本来区分静态资源。这样静态资源会生成不同的资源访问链接，不会产生修改之后无法感知的情况。