# 性能优化排查与处理

## 排查流程

```
1. Lighthouse 整体评估（发现问题）
         ↓
2. Performance 面板（定位瓶颈）
         ↓
3. Network 面板（资源分析）
         ↓
4. 打包分析工具（深入代码）
         ↓
5. 针对性优化处理
         ↓
6. 视觉体验优化
```

## 1. Lighthouse 整体评估

### 为什么先用 Lighthouse？

- 给出整体性能评分
- 提供具体优化建议
- 快速定位问题类型

### 使用方式

```
Chrome DevTools → Lighthouse → Generate report
```

**评分维度：**

| 指标 | 说明 | 优化目标 |
|------|------|----------|
| Performance | 性能评分 | > 90 |
| Accessibility | 可访问性 | > 90 |
| Best Practices | 最佳实践 | > 90 |
| SEO | 搜索引擎优化 | > 90 |

**核心指标：**

| 指标 | 说明 | 优化目标 | 常见问题 |
|------|------|----------|----------|
| FCP | 首次内容绘制 | < 1.8s | 关键资源加载慢 |
| LCP | 最大内容绘制 | < 2.5s | 图片/视频过大 |
| TTI | 可交互时间 | < 3.8s | JS 执行时间长 |
| TBT | 总阻塞时间 | < 200ms | 长任务阻塞主线程 |
| CLS | 累积布局偏移 | < 0.1 | 图片未设置尺寸 |

## 2. Performance 面板（重点）

### 为什么要用 Performance？

Network 只能看资源加载，看不到：
- JS 执行是否耗时
- 是否有长任务阻塞
- 渲染性能（重排重绘）
- 内存是否泄漏

### 使用方式

```
1. 打开 Performance 面板
2. 点击录制按钮
3. 刷新页面或操作页面
4. 停止录制，查看火焰图
```

### 关键指标

**Main（主线程）：**
- 黄色：JS 执行
- 紫色：渲染和布局
- 绿色：绘制

**查看重点：**
```
长任务（Long Task）：超过 50ms 的任务会阻塞主线程
  → 需要拆分任务或使用 Web Worker

FPS（帧率）：低于 60fps 会感觉卡顿
  → 检查是否频繁重排重绘

内存：持续增长不释放
  → 可能存在内存泄漏
```

### 常见问题定位

| 现象 | 原因 | 解决方案 |
|------|------|----------|
| 页面加载慢 | 关键资源体积大 | 代码分割、懒加载 |
| 交互卡顿 | JS 长任务阻塞 | 拆分任务、防抖节流 |
| 滚动不流畅 | 频繁重排重绘 | 使用 transform、will-change |
| 内存持续增长 | 内存泄漏 | 清理定时器、事件监听 |

## 3. Network 面板

### 查看内容

- 资源加载时间
- 文件体积大小
- 请求数量
- 瀑布流分析

### 关键指标

```
DOMContentLoaded: DOM 解析完成时间（蓝线）
Load: 页面完全加载时间（红线）
Finish: 所有请求完成时间
```

### 常见问题

| 问题 | 判断标准 | 解决方案 |
|------|----------|----------|
| 文件体积过大 | 单个文件 > 500KB | 代码分割、压缩 |
| 请求数量过多 | 超过 50 个请求 | 合并资源、雪碧图 |
| 首屏白屏时间长 | FCP > 2s | 预加载关键资源 |
| 资源加载慢 | 某个资源 > 3s | 使用 CDN、压缩 |

## 4. 打包分析工具

### Webpack 项目

```bash
npm install webpack-bundle-analyzer -D
```

```js
// webpack.config.js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

### Vite 项目

```bash
npm install rollup-plugin-visualizer -D
```

```js
// vite.config.js
import { visualizer } from 'rollup-plugin-visualizer'

export default {
  plugins: [
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true
    })
  ]
}
```

**分析内容：**
- 哪些依赖包体积最大
- 是否有重复打包的模块
- 未使用的代码是否被打包（Tree Shaking 是否生效）

## 5. 优化处理（按收益排序）

### 优先级 1：代码分割 + 路由懒加载

```js
// 路由懒加载
const routes = [
  {
    path: '/home',
    component: () => import('./views/Home.vue')
  }
]

// 代码分割
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendor: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        priority: 10
      }
    }
  }
}
```

### 优先级 2：按需引入

```js
// Element Plus 按需引入
import { ElButton, ElInput } from 'element-plus'

// Lodash 按需引入
import debounce from 'lodash/debounce'  // ✅
// import _ from 'lodash'  // ❌ 会引入整个库
```

### 优先级 3：图片优化

**1. 压缩图片**
```bash
# 使用 tinypng、imagemin 等工具
npm install imagemin imagemin-pngquant -D
```

**2. 使用 webp 格式**
```html
<picture>
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="图片">
</picture>
```

**3. 缩略图过渡**
```vue
<template>
  <img 
    :src="isLoaded ? originalImg : thumbnailImg" 
    @load="isLoaded = true"
    class="progressive-img"
  />
</template>

<script setup>
import { ref } from 'vue'

const isLoaded = ref(false)
const thumbnailImg = 'thumbnail.jpg'  // 小图（几KB）
const originalImg = 'original.jpg'    // 原图
</script>

<style>
.progressive-img {
  filter: blur(10px);
  transition: filter 0.3s;
}

.progressive-img[src*="original"] {
  filter: blur(0);
}
</style>
```

**4. 图片懒加载**
```js
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target
      img.src = img.dataset.src
      observer.unobserve(img)
    }
  })
})

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img)
})
```

### 优先级 4：Gzip 压缩

**Nginx 配置：**
```nginx
gzip on;
gzip_types text/plain text/css application/json application/javascript;
gzip_min_length 1000;
gzip_comp_level 6;
```

## 6. 视觉体验优化

### 骨架屏

### Loading 动画

### 渐进式加载

```js
// 图片懒加载（已在上面优化处理中）
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target
      img.src = img.dataset.src
      observer.unobserve(img)
    }
  })
})
```

## 7. 其他优化手段

### CDN 加速

### 预加载/预连接

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="main.js" as="script">

<!-- 预连接第三方域名 -->
<link rel="preconnect" href="https://api.example.com">

<!-- DNS 预解析 -->
<link rel="dns-prefetch" href="https://cdn.example.com">
```

### 缓存策略

```nginx
# Nginx 配置强缓存
location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
  expires 1y;
  add_header Cache-Control "public, immutable";
}
```

## 排查清单

### 第一步：Lighthouse 评估
- [ ] 运行 Lighthouse 获取整体评分
- [ ] 查看具体优化建议
- [ ] 记录 FCP、LCP、TTI、TBT、CLS 指标

### 第二步：Performance 分析
- [ ] 录制页面加载过程
- [ ] 查看是否有长任务（> 50ms）
- [ ] 检查 FPS 是否低于 60
- [ ] 查看内存是否持续增长

### 第三步：Network 分析
- [ ] 查看资源加载时间
- [ ] 检查是否有大文件（> 500KB）
- [ ] 统计请求数量
- [ ] 查看 DOMContentLoaded 和 Load 时间

### 第四步：打包分析
- [ ] 使用打包分析工具查看体积分布
- [ ] 检查是否有重复打包的模块
- [ ] 确认 Tree Shaking 是否生效

### 第五步：针对性优化
- [ ] 代码分割 + 路由懒加载
- [ ] 第三方库按需引入
- [ ] 图片压缩/webp/懒加载
- [ ] 开启 Gzip 压缩
- [ ] 拆分长任务

### 第六步：体验优化
- [ ] 添加骨架屏/Loading
- [ ] 缩略图过渡
- [ ] 使用 CDN

## 面试要点

1. **性能优化的排查流程？** Lighthouse → Performance → Network → 打包分析
2. **Performance 面板能看到什么？** JS 执行时间、长任务、渲染性能、内存
3. **什么是长任务？** 超过 50ms 的任务会阻塞主线程，导致页面卡顿
4. **优化的优先级？** 代码分割 > 按需引入 > 图片优化 > Gzip
5. **Lighthouse 核心指标？** FCP、LCP、TTI、TBT、CLS
6. **如何优化用户体验？** 骨架屏、Loading、缩略图过渡
7. **如何解决页面卡顿？** 拆分长任务、使用 Web Worker、防抖节流
8. **内存泄漏如何排查？** Performance 面板查看内存是否持续增长
