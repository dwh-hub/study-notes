# 自动化部署

## 部署方案选择

### GitLab CI/CD

GitLab 自带的 CI/CD 功能，配置简单，与代码仓库集成度高

| 优点 | 缺点 |
|------|------|
| 配置文件在项目中，版本可控 | 依赖 GitLab Runner |
| 与 GitLab 无缝集成 | 功能相对 Jenkins 简单 |
| 免费版功能够用 | |

### Jenkins

老牌 CI/CD 工具，功能强大，插件丰富

| 优点 | 缺点 |
|------|------|
| 插件生态丰富 | 配置相对复杂 |
| 可视化配置界面 | 需要单独部署维护 |
| 支持复杂的构建流程 | |

## GitLab CI/CD 实战

### 1. 创建配置文件

在项目根目录创建 `.gitlab-ci.yml`

```yaml
# 定义构建阶段
stages:
  - build
  - deploy

# 构建任务
build:
  stage: build
  image: node:18  # 使用 Node 18 的 Docker 镜像
  cache:
    paths:
      - node_modules/  # 缓存依赖
  script:
    - npm install
    - npm run build
  artifacts:
    paths:
      - dist/  # 保存构建产物
    expire_in: 1 hour
  only:
    - master  # 只在 master 分支触发

# 部署任务
deploy:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client  # 安装 SSH 客户端
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVER_IP >> ~/.ssh/known_hosts
  script:
    - scp -r dist/* $SERVER_USER@$SERVER_IP:$SERVER_PATH
  only:
    - master
```

### 2. 触发策略

**自动触发（推荐）**
```yaml
only:
  - master  # master 分支有 push 就自动构建
```

**手动触发**
```yaml
when: manual  # 需要在 GitLab 界面手动点击触发
```

**定时触发**
```yaml
# 在 GitLab 项目设置 → CI/CD → Schedules 中配置
# 例如：每天凌晨 2 点自动构建
```

**Tag 触发**
```yaml
only:
  - tags  # 只在打 tag 时触发
```

### 3. 环境变量配置

在 GitLab 项目设置 → CI/CD → Variables 中添加：

| 变量名 | 说明 | 示例 |
|--------|------|------|
| SSH_PRIVATE_KEY | SSH 私钥 | -----BEGIN RSA PRIVATE KEY----- |
| SERVER_IP | 服务器 IP | 192.168.1.100 |
| SERVER_USER | 服务器用户名 | root |
| SERVER_PATH | 部署路径 | /var/www/html |

### 4. 多环境部署

```yaml
stages:
  - build
  - deploy

# 构建
build:
  stage: build
  image: node:18
  script:
    - npm install
    - npm run build
  artifacts:
    paths:
      - dist/

# 部署到测试环境
deploy:test:
  stage: deploy
  script:
    - scp -r dist/* $TEST_SERVER_USER@$TEST_SERVER_IP:$TEST_SERVER_PATH
  only:
    - dev
  environment:
    name: test
    url: https://test.example.com

# 部署到生产环境
deploy:prod:
  stage: deploy
  script:
    - scp -r dist/* $PROD_SERVER_USER@$PROD_SERVER_IP:$PROD_SERVER_PATH
  only:
    - master
  when: manual  # 生产环境手动触发
  environment:
    name: production
    url: https://www.example.com
```

## Jenkins 实战

### 1. 创建 Jenkinsfile

```groovy
pipeline {
  agent {
    docker {
      image 'node:18'  // 使用 Docker 镜像
    }
  }
  
  stages {
    stage('安装依赖') {
      steps {
        sh 'npm install'
      }
    }
    
    stage('构建') {
      steps {
        sh 'npm run build'
      }
    }
    
    stage('部署') {
      steps {
        sshPublisher(
          publishers: [
            sshPublisherDesc(
              configName: 'production-server',
              transfers: [
                sshTransfer(
                  sourceFiles: 'dist/**',
                  removePrefix: 'dist',
                  remoteDirectory: '/var/www/html'
                )
              ]
            )
          ]
        )
      }
    }
  }
  
  triggers {
    // 监听 master 分支的 push 事件
    githubPush()
  }
}
```

### 2. 触发方式

**Webhook 自动触发**
1. Jenkins 安装 GitLab/GitHub 插件
2. 在 GitLab/GitHub 项目设置中添加 Webhook
3. URL: `http://jenkins.example.com/project/your-project`

**定时触发**
```groovy
triggers {
  cron('H 2 * * *')  // 每天凌晨 2 点
}
```

**手动触发**
- 在 Jenkins 界面点击"立即构建"

## Docker 化部署

### Dockerfile

```dockerfile
# 构建阶段
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# 运行阶段
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### GitLab CI 配置

```yaml
stages:
  - build
  - deploy

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t my-app:$CI_COMMIT_SHA .
    - docker tag my-app:$CI_COMMIT_SHA my-app:latest
    - docker push my-app:latest

deploy:
  stage: deploy
  script:
    - ssh $SERVER_USER@$SERVER_IP "docker pull my-app:latest"
    - ssh $SERVER_USER@$SERVER_IP "docker stop my-app || true"
    - ssh $SERVER_USER@$SERVER_IP "docker rm my-app || true"
    - ssh $SERVER_USER@$SERVER_IP "docker run -d -p 80:80 --name my-app my-app:latest"
```

## 部署流程总结

```
1. 代码推送到 GitLab/GitHub
         ↓
2. 触发 CI/CD（自动/手动/定时）
         ↓
3. 拉取 Docker 镜像（包含 Node 环境）
         ↓
4. 安装依赖 & 执行构建命令
         ↓
5. 通过 SSH 推送构建产物到服务器
         ↓
6. 服务器重启服务（Nginx/Docker）
```

## 常见问题

### 2. 构建缓存

```yaml
# GitLab CI 缓存依赖
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .npm/
```

### 3. 构建失败通知

```yaml
# GitLab CI 发送邮件通知
after_script:
  - echo "构建完成"

# 或使用钉钉/企业微信 Webhook
script:
  - |
    if [ "$CI_JOB_STATUS" == "failed" ]; then
      curl -X POST $DINGTALK_WEBHOOK \
        -H 'Content-Type: application/json' \
        -d '{"msgtype":"text","text":{"content":"构建失败"}}'
    fi
```

## 最佳实践

1. **环境隔离** - 测试环境自动部署，生产环境手动触发
2. **回滚机制** - 保留历史版本，支持快速回滚
3. **健康检查** - 部署后自动检查服务是否正常
4. **通知机制** - 构建失败及时通知相关人员
5. **权限控制** - 生产环境部署权限严格控制
6. **日志记录** - 保留构建日志，方便排查问题

## 对比总结

| 特性 | GitLab CI | Jenkins |
|------|-----------|---------|
| 配置方式 | YAML 文件 | Jenkinsfile / UI |
| 学习成本 | 低 | 中 |
| 功能丰富度 | 中 | 高 |
| 维护成本 | 低 | 中 |
| 适用场景 | 中小型项目 | 大型复杂项目 |

**推荐：** 如果用 GitLab 管理代码，优先选择 GitLab CI；如果需要复杂的构建流程，选择 Jenkins
