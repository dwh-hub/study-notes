# 通用组件设计

以 Modal 弹窗为例，讲讲如何设计一个好用的通用组件。

## 设计原则

### 1. 单一职责原则

**一个组件只做一件事**

```js
// ❌ 职责不清晰
<UserSelectModal 
  :show-approval="true"
  :enable-department="true"
  :with-permission-check="true"
/>

// ✅ 职责单一
<Modal v-model="visible">
  <UserSelect @change="handleSelect" />
</Modal>
```

**反例：** 一个 Select 组件既要选人又要选部门，还自带复杂的审批流逻辑，这样的组件维护成本极高，最终会被废弃。

**正确做法：** Modal 只负责弹窗的显示/隐藏、遮罩、动画，内容由插槽决定。

### 2. Props 设计

#### 类型检查

```vue
<script setup>
defineProps({
  visible: {
    type: Boolean,
    required: true
  },
  title: {
    type: String,
    default: '提示'
  },
  width: {
    type: [String, Number],
    default: '500px'
  },
  maskClosable: {
    type: Boolean,
    default: true
  }
})
</script>
```

#### 命名规范

| 类型 | 命名规范 | 示例 |
|------|----------|------|
| Boolean | is/has/show 开头 | isLoading, hasError, showFooter |
| 事件回调 | on 开头 | onConfirm, onCancel |
| 数据 | 名词 | title, content, data |
| 配置 | 形容词 | closable, maskClosable |

```vue
<script setup>
defineProps({
  // ✅ 好的命名
  isLoading: Boolean,
  showFooter: Boolean,
  maskClosable: Boolean,
  
  // ❌ 不好的命名
  loading: Boolean,      // 不明确是状态还是配置
  footer: Boolean,       // 不明确是显示还是内容
  mask: Boolean          // 不明确是显示遮罩还是可点击
})
</script>
```

#### 必填与默认值

```js
defineProps({
  // 必填项
  visible: {
    type: Boolean,
    required: true
  },
  
  // 可选项必须有默认值
  title: {
    type: String,
    default: ''
  },
  
  // 对象/数组默认值用工厂函数
  config: {
    type: Object,
    default: () => ({})
  }
})
```

### 3. Event 设计（数据单向流）

**核心原则：** 子组件不直接修改父组件传来的 Prop

```vue
<!-- ❌ 错误：直接修改 prop -->
<script setup>
const props = defineProps({
  visible: Boolean
})

const close = () => {
  props.visible = false  // 错误！
}
</script>

<!-- ✅ 正确：通过事件通知父组件 -->
<script setup>
const props = defineProps({
  visible: Boolean
})

const emit = defineEmits(['update:visible'])

const close = () => {
  emit('update:visible', false)
}
</script>
```

#### v-model 双向绑定

```vue
<!-- Modal.vue -->
<script setup>
defineProps({
  visible: Boolean
})

const emit = defineEmits(['update:visible'])

const handleClose = () => {
  emit('update:visible', false)
}
</script>

<template>
  <div v-if="visible" class="modal">
    <div class="modal-mask" @click="handleClose"></div>
    <div class="modal-content">
      <slot></slot>
    </div>
  </div>
</template>

<!-- 使用 -->
<Modal v-model:visible="showModal">
  <p>弹窗内容</p>
</Modal>
```

#### 事件命名规范

```js
// ✅ 好的事件命名
emit('confirm', data)      // 确认
emit('cancel')             // 取消
emit('update:visible', false)  // 更新状态
emit('change', value)      // 值改变

// ❌ 不好的事件命名
emit('ok')                 // 不明确
emit('close')              // 和内部方法混淆
emit('submit')             // 太具体，限制使用场景
```

### 4. 插槽设计（扩展性）

**核心思想：** 给用户留出自定义的空间

```vue
<!-- Modal.vue -->
<template>
  <div v-if="visible" class="modal">
    <div class="modal-mask"></div>
    <div class="modal-content">
      <!-- 头部插槽 -->
      <div class="modal-header">
        <slot name="header">
          <h3>{{ title }}</h3>
        </slot>
      </div>
      
      <!-- 内容插槽 -->
      <div class="modal-body">
        <slot></slot>
      </div>
      
      <!-- 底部插槽 -->
      <div v-if="showFooter" class="modal-footer">
        <slot name="footer">
          <button @click="handleCancel">取消</button>
          <button @click="handleConfirm">确定</button>
        </slot>
      </div>
    </div>
  </div>
</template>
```

#### 插槽使用场景

```vue
<!-- 1. 使用默认内容 -->
<Modal v-model:visible="visible" title="提示">
  <p>确定要删除吗？</p>
</Modal>

<!-- 2. 自定义头部 -->
<Modal v-model:visible="visible">
  <template #header>
    <div class="custom-header">
      <Icon name="warning" />
      <span>警告</span>
    </div>
  </template>
  <p>这是一个警告弹窗</p>
</Modal>

<!-- 3. 自定义底部 -->
<Modal v-model:visible="visible" title="表单">
  <Form ref="formRef" />
  <template #footer>
    <button @click="handleReset">重置</button>
    <button @click="handleSubmit">提交</button>
  </template>
</Modal>
```

#### 作用域插槽

```vue
<!-- Modal.vue -->
<template>
  <div class="modal-footer">
    <slot name="footer" :loading="loading" :close="handleClose">
      <button :disabled="loading" @click="handleClose">取消</button>
      <button :loading="loading" @click="handleConfirm">确定</button>
    </slot>
  </div>
</template>

<!-- 使用 -->
<Modal v-model:visible="visible">
  <template #footer="{ loading, close }">
    <button @click="close">关闭</button>
    <button :disabled="loading">{{ loading ? '提交中...' : '提交' }}</button>
  </template>
</Modal>
```

### 5. 低耦合度

**核心原则：** 通用组件严禁包含具体的业务逻辑和接口请求

```vue
<!-- ❌ 错误：组件内部请求接口 -->
<script setup>
import { getUserList } from '@/api/user'

const props = defineProps({
  visible: Boolean
})

const userList = ref([])

watch(() => props.visible, async (val) => {
  if (val) {
    userList.value = await getUserList()  // 耦合了业务接口
  }
})
</script>

<!-- ✅ 正确：数据由父组件传入 -->
<script setup>
defineProps({
  visible: Boolean,
  userList: {
    type: Array,
    default: () => []
  }
})
</script>

<!-- 父组件负责数据获取 -->
<template>
  <Modal v-model:visible="visible" :user-list="userList" />
</template>

<script setup>
import { getUserList } from '@/api/user'

const userList = ref([])

const loadData = async () => {
  userList.value = await getUserList()
}
</script>
```

#### 配置化而非硬编码

```vue
<!-- ❌ 硬编码 -->
<script setup>
const statusMap = {
  1: '待审核',
  2: '已通过',
  3: '已拒绝'
}
</script>

<!-- ✅ 配置化 -->
<script setup>
defineProps({
  statusMap: {
    type: Object,
    default: () => ({})
  }
})
</script>

<!-- 使用时传入配置 -->
<StatusTag :status-map="{ 1: '待审核', 2: '已通过' }" />
```

## 总结

1. 组件职责单一
2. Props的类型检查和默认值
3. 命名符合规范（Boolean 用 is/has/show）？
4. 遵循数据单向流（不直接修改 prop）
5. 预留插槽位置增强扩展性？
6. 不能包含业务逻辑或接口请求

## 要点

1. **单一职责原则是什么？** 一个组件只做一件事，不要把业务逻辑耦合进去
2. **为什么不能直接修改 prop？** 违反数据单向流，难以追踪数据变化
3. **插槽的作用是什么？** 提供扩展点，让组件更灵活
4. **通用组件能包含接口请求吗？** 不能，数据应由父组件传入
5. **如何设计一个好的 API？** 类型检查、默认值、命名规范、事件清晰
6. **作用域插槽的使用场景？** 需要向插槽传递数据时使用
