# 菜单权限

前端权限控制分为两部分：菜单权限（路由级别）和按钮权限（操作级别）。

## 1. 菜单权限（动态路由）

### 核心思路

1. 用户登录后，后端返回该用户的菜单列表（menuList）
2. 前端根据 menuList 动态生成路由
3. 使用 `addRoute` 动态挂载路由

### Vue 3 实现

#### 路由配置

```js
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'

// 静态路由（无需权限）
const constantRoutes = [
  {
    path: '/login',
    component: () => import('@/views/Login.vue')
  },
  {
    path: '/404',
    component: () => import('@/views/404.vue')
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes: constantRoutes
})

export default router
```

#### 动态路由生成

```js
// router/permission.js
import router from './index'
import { getUserMenus } from '@/api/user'

// 路由组件映射
const modules = import.meta.glob('../views/**/*.vue')

// 将后端返回的菜单转换为路由
const generateRoutes = (menuList) => {
  const routes = []
  
  menuList.forEach(menu => {
    const route = {
      path: menu.path,
      name: menu.name,
      component: modules[`../views${menu.component}.vue`],
      meta: {
        title: menu.title,
        icon: menu.icon
      }
    }
    
    // 递归处理子菜单
    if (menu.children && menu.children.length) {
      route.children = generateRoutes(menu.children)
    }
    
    routes.push(route)
  })
  
  return routes
}

// 动态添加路由
export const addDynamicRoutes = async () => {
  try {
    // 获取用户菜单
    const menuList = await getUserMenus()
    
    // 生成路由
    const routes = generateRoutes(menuList)
    
    // 动态添加
    routes.forEach(route => {
      router.addRoute(route)
    })
    
    // 添加 404 路由（必须放最后）
    router.addRoute({
      path: '/:pathMatch(.*)*',
      redirect: '/404'
    })
    
    return routes
  } catch (error) {
    console.error('加载路由失败', error)
  }
}
```

#### 路由守卫

```js
// router/guard.js
import router from './index'
import { addDynamicRoutes } from './permission'

// 是否已添加动态路由
let hasAddedRoutes = false

router.beforeEach(async (to, from, next) => {
  const token = localStorage.getItem('token')
  
  // 未登录
  if (!token) {
    if (to.path === '/login') {
      next()
    } else {
      next('/login')
    }
    return
  }
  
  // 已登录，访问登录页，跳转首页
  if (to.path === '/login') {
    next('/')
    return
  }
  
  // 动态添加路由
  if (!hasAddedRoutes) {
    await addDynamicRoutes()
    hasAddedRoutes = true
    next({ ...to, replace: true })  // 重新进入路由
  } else {
    next()
  }
})
```

### React 18 实现

#### 路由配置

```jsx
// router/index.jsx
import { lazy } from 'react'
import { Navigate } from 'react-router-dom'

// 静态路由
export const constantRoutes = [
  {
    path: '/login',
    element: lazy(() => import('@/pages/Login'))
  },
  {
    path: '/404',
    element: lazy(() => import('@/pages/404'))
  }
]
```

#### 动态路由生成

```jsx
// router/permission.js
import { lazy } from 'react'

// 将后端菜单转换为路由
export const generateRoutes = (menuList) => {
  const routes = []
  
  menuList.forEach(menu => {
    const route = {
      path: menu.path,
      element: lazy(() => import(`@/pages${menu.component}`)),
      meta: {
        title: menu.title,
        icon: menu.icon
      }
    }
    
    // 递归处理子路由
    if (menu.children && menu.children.length) {
      route.children = generateRoutes(menu.children)
    }
    
    routes.push(route)
  })
  
  return routes
}
```

#### 路由守卫组件

```jsx
// components/AuthRoute.jsx
import { useEffect, useState } from 'react'
import { Navigate, useRoutes } from 'react-router-dom'
import { getUserMenus } from '@/api/user'
import { constantRoutes, generateRoutes } from '@/router'

export default function AuthRoute() {
  const [routes, setRoutes] = useState(constantRoutes)
  const token = localStorage.getItem('token')
  
  useEffect(() => {
    if (token) {
      loadDynamicRoutes()
    }
  }, [token])
  
  const loadDynamicRoutes = async () => {
    try {
      const menuList = await getUserMenus()
      const dynamicRoutes = generateRoutes(menuList)
      
      // 合并路由
      setRoutes([
        ...constantRoutes,
        ...dynamicRoutes,
        { path: '*', element: <Navigate to="/404" /> }
      ])
    } catch (error) {
      console.error('加载路由失败', error)
    }
  }
  
  const element = useRoutes(routes)
  
  return element
}
```

#### App.jsx

```jsx
// App.jsx
import { BrowserRouter } from 'react-router-dom'
import AuthRoute from '@/components/AuthRoute'

function App() {
  return (
    <BrowserRouter>
      <AuthRoute />
    </BrowserRouter>
  )
}

export default App
```

## 2. 按钮权限（自定义指令/组件）

### 核心思路

1. 后端返回用户的权限列表（permissionList）
2. 前端封装权限判断逻辑
3. 无权限时移除 DOM 元素

### Vue 3 实现

#### 自定义指令

```js
// directives/auth.js
import { useUserStore } from '@/store/user'

export default {
  mounted(el, binding) {
    const { value } = binding
    const userStore = useUserStore()
    const permissions = userStore.permissions
    
    // 判断是否有权限
    const hasPermission = permissions.includes(value)
    
    if (!hasPermission) {
      // 物理移除 DOM
      el.parentNode?.removeChild(el)
    }
  }
}
```

#### 注册指令

```js
// main.js
import { createApp } from 'vue'
import App from './App.vue'
import auth from './directives/auth'

const app = createApp(App)

app.directive('auth', auth)

app.mount('#app')
```

#### 使用示例

```vue
<template>
  <div>
    <!-- 有 user:add 权限才显示 -->
    <button v-auth="'user:add'">新增用户</button>
    
    <!-- 有 user:delete 权限才显示 -->
    <button v-auth="'user:delete'">删除用户</button>
  </div>
</template>
```

#### 权限判断函数（可选）

```js
// utils/auth.js
import { useUserStore } from '@/store/user'

export const hasPermission = (permission) => {
  const userStore = useUserStore()
  return userStore.permissions.includes(permission)
}

// 使用
<button v-if="hasPermission('user:add')">新增用户</button>
```

### React 18 实现

#### 权限组件

```jsx
// components/Auth.jsx
import { useSelector } from 'react-redux'

export default function Auth({ permission, children }) {
  const permissions = useSelector(state => state.user.permissions)
  
  // 判断是否有权限
  const hasPermission = permissions.includes(permission)
  
  // 无权限返回 null（不渲染）
  return hasPermission ? children : null
}
```

#### 使用示例

```jsx
import Auth from '@/components/Auth'

function UserPage() {
  return (
    <div>
      {/* 有权限才显示 */}
      <Auth permission="user:add">
        <button>新增用户</button>
      </Auth>
      
      <Auth permission="user:delete">
        <button>删除用户</button>
      </Auth>
    </div>
  )
}
```

#### 权限 Hook（可选）

```jsx
// hooks/useAuth.js
import { useSelector } from 'react-redux'

export const useAuth = (permission) => {
  const permissions = useSelector(state => state.user.permissions)
  return permissions.includes(permission)
}

// 使用
function UserPage() {
  const canAdd = useAuth('user:add')
  const canDelete = useAuth('user:delete')
  
  return (
    <div>
      {canAdd && <button>新增用户</button>}
      {canDelete && <button>删除用户</button>}
    </div>
  )
}
```

## 3. 后端数据格式

### 菜单列表

```json
{
  "code": 200,
  "data": [
    {
      "id": 1,
      "name": "User",
      "path": "/user",
      "component": "/User/index",
      "title": "用户管理",
      "icon": "user",
      "children": [
        {
          "id": 2,
          "name": "UserList",
          "path": "/user/list",
          "component": "/User/List",
          "title": "用户列表",
          "icon": "list"
        }
      ]
    },
    {
      "id": 3,
      "name": "System",
      "path": "/system",
      "component": "/System/index",
      "title": "系统管理",
      "icon": "setting"
    }
  ]
}
```

### 权限列表

```json
{
  "code": 200,
  "data": {
    "permissions": [
      "user:add",
      "user:edit",
      "user:delete",
      "user:view",
      "system:config"
    ]
  }
}
```

## 4. 完整流程

```
1. 用户登录
         ↓
2. 后端返回 Token + 菜单列表 + 权限列表
         ↓
3. 前端存储到 Store/Redux
         ↓
4. 路由守卫中动态添加路由
         ↓
5. 页面中使用指令/组件控制按钮显示
```

## 5. 注意事项

### 刷新页面路由丢失

**问题：** 动态添加的路由在刷新后会丢失

**解决：** 在路由守卫中判断，如果未添加则重新添加

```js
// Vue
let hasAddedRoutes = false

router.beforeEach(async (to, from, next) => {
  if (!hasAddedRoutes) {
    await addDynamicRoutes()
    hasAddedRoutes = true
    next({ ...to, replace: true })
  } else {
    next()
  }
})
```

### 404 路由必须最后添加

**原因：** 404 路由会匹配所有路径，如果先添加，动态路由会失效

```js
// ✅ 正确：最后添加
routes.forEach(route => router.addRoute(route))
router.addRoute({ path: '/:pathMatch(.*)*', redirect: '/404' })

// ❌ 错误：先添加 404
router.addRoute({ path: '/:pathMatch(.*)*', redirect: '/404' })
routes.forEach(route => router.addRoute(route))
```

### 权限数据持久化

```js
// 存储到 localStorage
localStorage.setItem('permissions', JSON.stringify(permissions))

// 刷新时恢复
const permissions = JSON.parse(localStorage.getItem('permissions') || '[]')
```

## 对比总结

| 特性 | Vue 3 | React 18 |
|------|-------|----------|
| 动态路由 | router.addRoute() | useRoutes() 动态生成 |
| 按钮权限 | 自定义指令 v-auth | 权限组件 Auth |
| 路由守卫 | router.beforeEach | 路由守卫组件 |
| 状态管理 | Pinia/Vuex | Redux/Zustand |

## 总结

1. **菜单权限**：登录后获取菜单列表，使用 `addRoute` 动态挂载路由
2. **按钮权限**：封装指令/组件，根据权限列表判断是否显示
3. **数据持久化**：权限数据存储到 localStorage，刷新时恢复
4. **404 路由**：必须最后添加，否则会拦截所有动态路由
5. **安全性**：前端权限只是 UI 控制，后端必须做接口权限校验

## 要点

1. **前端权限控制的两种方式？** 菜单权限（路由级别）、按钮权限（操作级别）
2. **动态路由如何实现？** 登录后获取菜单，使用 addRoute 动态添加
3. **为什么 404 要最后添加？** 404 会匹配所有路径，先添加会拦截动态路由
4. **刷新页面路由丢失怎么办？** 在路由守卫中判断，未添加则重新添加
5. **前端权限控制安全吗？** 不安全，只是 UI 控制，后端必须做接口权限校验
6. **Vue 和 React 权限实现的区别？** Vue 用指令，React 用组件/Hook
