# 接口封装

基于 Axios 的接口封装

## 1. 多环境配置

### 环境变量配置

```bash
# .env.development
VITE_API_URL=http://localhost:3000/api

# .env.test
VITE_API_URL=https://test.example.com/api

# .env.production
VITE_API_URL=https://api.example.com
```

### 基础配置

```js
// request.js
import axios from 'axios'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_URL,  // 自动根据环境切换
  timeout: 10000
})

export default request
```

## 2. 请求拦截器

### 注入 Token

```js
request.interceptors.request.use(
  (config) => {
    // 从本地存储获取 Token
    const token = localStorage.getItem('token')
    
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)
```

### 全局 Loading

```js
import { ElLoading } from 'element-plus'

let loadingInstance = null
let requestCount = 0  // 记录请求数量

request.interceptors.request.use(
  (config) => {
    // 可以通过配置控制是否显示 Loading
    if (config.showLoading !== false) {
      requestCount++
      
      if (!loadingInstance) {
        loadingInstance = ElLoading.service({
          lock: true,
          text: '加载中...',
          background: 'rgba(0, 0, 0, 0.7)'
        })
      }
    }
    
    return config
  }
)
```

### 请求参数处理

```js
request.interceptors.request.use(
  (config) => {
    // GET 请求参数序列化
    if (config.method === 'get' && config.params) {
      config.paramsSerializer = (params) => {
        return qs.stringify(params, { arrayFormat: 'brackets' })
      }
    }
    
    // POST 请求时间戳防缓存
    if (config.method === 'post') {
      config.data = {
        ...config.data,
        _t: Date.now()
      }
    }
    
    return config
  }
)
```

## 3. 响应拦截器

### 统一状态码处理

```js
import { ElMessage } from 'element-plus'
import router from '@/router'

request.interceptors.response.use(
  (response) => {
    const { code, data, message } = response.data
    
    // 根据业务状态码处理
    switch (code) {
      case 200:
        return data  // 数据脱壳，直接返回 data
        
      case 401:
        // 未登录，跳转登录页
        ElMessage.error('登录已过期，请重新登录')
        localStorage.removeItem('token')
        router.push('/login')
        return Promise.reject(new Error(message))
        
      case 403:
        // 无权限
        ElMessage.error('无权限访问')
        return Promise.reject(new Error(message))
        
      case 500:
        // 服务器错误
        ElMessage.error(message || '服务器错误')
        return Promise.reject(new Error(message))
        
      default:
        ElMessage.error(message || '请求失败')
        return Promise.reject(new Error(message))
    }
  },
  (error) => {
    // 关闭 Loading
    closeLoading()
    
    // 网络错误处理
    if (error.message.includes('timeout')) {
      ElMessage.error('请求超时，请稍后重试')
    } else if (error.message.includes('Network Error')) {
      ElMessage.error('网络连接失败')
    } else {
      ElMessage.error(error.message || '请求失败')
    }
    
    return Promise.reject(error)
  }
)

// 关闭 Loading
function closeLoading() {
  requestCount--
  
  if (requestCount === 0 && loadingInstance) {
    loadingInstance.close()
    loadingInstance = null
  }
}
```

### 数据脱壳

```js
// 业务层使用
const getUserInfo = async () => {
  // 不需要 res.data.data，直接拿到数据
  const data = await request.get('/user/info')
  console.log(data)  // { id: 1, name: 'xxx' }
}
```

## 4. 请求取消机制

### 为什么需要取消请求？

1. **路由切换时**：上一个页面的请求还在 pending，切换后数据无用
2. **防止内存泄漏**：组件销毁后请求回来，setState 会报错
3. **防止数据覆盖**：快速切换时，旧请求可能比新请求晚返回

### 实现方式

```js
// request.js
import axios from 'axios'

// 存储所有 pending 的请求
const pendingRequests = new Map()

// 生成请求的唯一 key
const getRequestKey = (config) => {
  return `${config.method}_${config.url}_${JSON.stringify(config.params)}_${JSON.stringify(config.data)}`
}

// 添加请求到 pending 列表
const addPendingRequest = (config) => {
  const key = getRequestKey(config)
  
  config.cancelToken = new axios.CancelToken((cancel) => {
    if (!pendingRequests.has(key)) {
      pendingRequests.set(key, cancel)
    }
  })
}

// 移除 pending 请求
const removePendingRequest = (config) => {
  const key = getRequestKey(config)
  
  if (pendingRequests.has(key)) {
    const cancel = pendingRequests.get(key)
    cancel(key)  // 取消请求
    pendingRequests.delete(key)
  }
}

// 清空所有 pending 请求
export const clearPendingRequests = () => {
  pendingRequests.forEach((cancel) => {
    cancel('路由切换，取消请求')
  })
  pendingRequests.clear()
}

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 取消重复请求
    removePendingRequest(config)
    // 添加到 pending 列表
    addPendingRequest(config)
    
    return config
  }
)

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    // 请求完成，从 pending 列表移除
    removePendingRequest(response.config)
    return response
  },
  (error) => {
    // 请求失败，从 pending 列表移除
    if (error.config) {
      removePendingRequest(error.config)
    }
    
    // 判断是否是取消请求
    if (axios.isCancel(error)) {
      console.log('请求已取消:', error.message)
      return Promise.reject({ isCanceled: true })
    }
    
    return Promise.reject(error)
  }
)
```

### 路由守卫中使用

```js
// router/index.js
import { clearPendingRequests } from '@/utils/request'

router.beforeEach((to, from, next) => {
  // 路由切换时取消所有 pending 请求
  clearPendingRequests()
  next()
})
```

### 组件中手动取消

```vue
<script setup>
import { onBeforeUnmount } from 'vue'
import axios from 'axios'

const source = axios.CancelToken.source()

const fetchData = () => {
  request.get('/api/data', {
    cancelToken: source.token
  })
}

// 组件销毁时取消请求
onBeforeUnmount(() => {
  source.cancel('组件销毁，取消请求')
})
</script>
```

## 5. 完整封装示例

```js
// utils/request.js
import axios from 'axios'
import { ElMessage, ElLoading } from 'element-plus'
import router from '@/router'

// 创建实例
const request = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  timeout: 10000
})

// Loading 实例
let loadingInstance = null
let requestCount = 0

// Pending 请求管理
const pendingRequests = new Map()

const getRequestKey = (config) => {
  return `${config.method}_${config.url}_${JSON.stringify(config.params)}`
}

const addPendingRequest = (config) => {
  const key = getRequestKey(config)
  config.cancelToken = new axios.CancelToken((cancel) => {
    if (!pendingRequests.has(key)) {
      pendingRequests.set(key, cancel)
    }
  })
}

const removePendingRequest = (config) => {
  const key = getRequestKey(config)
  if (pendingRequests.has(key)) {
    const cancel = pendingRequests.get(key)
    cancel(key)
    pendingRequests.delete(key)
  }
}

export const clearPendingRequests = () => {
  pendingRequests.forEach((cancel) => cancel('路由切换'))
  pendingRequests.clear()
}

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 取消重复请求
    removePendingRequest(config)
    addPendingRequest(config)
    
    // 注入 Token
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    // 显示 Loading
    if (config.showLoading !== false) {
      requestCount++
      if (!loadingInstance) {
        loadingInstance = ElLoading.service({
          lock: true,
          text: '加载中...'
        })
      }
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    removePendingRequest(response.config)
    closeLoading()
    
    const { code, data, message } = response.data
    
    if (code === 200) {
      return data  // 数据脱壳
    }
    
    // 统一错误处理
    switch (code) {
      case 401:
        ElMessage.error('登录已过期')
        localStorage.removeItem('token')
        router.push('/login')
        break
      case 403:
        ElMessage.error('无权限访问')
        break
      default:
        ElMessage.error(message || '请求失败')
    }
    
    return Promise.reject(new Error(message))
  },
  (error) => {
    if (error.config) {
      removePendingRequest(error.config)
    }
    closeLoading()
    
    // 取消请求不提示
    if (axios.isCancel(error)) {
      return Promise.reject({ isCanceled: true })
    }
    
    // 网络错误
    if (error.message.includes('timeout')) {
      ElMessage.error('请求超时')
    } else if (error.message.includes('Network Error')) {
      ElMessage.error('网络连接失败')
    } else {
      ElMessage.error(error.message || '请求失败')
    }
    
    return Promise.reject(error)
  }
)

function closeLoading() {
  requestCount--
  if (requestCount === 0 && loadingInstance) {
    loadingInstance.close()
    loadingInstance = null
  }
}

export default request
```

## 总结

1. **多环境配置**：使用环境变量自动切换不同环境的 API 地址
2. **请求拦截器**：统一注入 Token、显示 Loading、处理请求参数
3. **响应拦截器**：统一处理状态码、数据脱壳、错误提示
4. **请求取消**：路由切换时自动取消 pending 请求，防止内存泄漏和数据覆盖

## 要点

1. **为什么要封装 Axios？** 统一处理 Token、错误、Loading，减少重复代码
2. **什么是数据脱壳？** 在拦截器中直接返回 `response.data.data`，业务层少写一层
3. **为什么要取消请求？** 防止内存泄漏、数据覆盖、无用请求占用资源
4. **如何实现请求取消？** 使用 CancelToken，在路由守卫中调用 `clearPendingRequests`
5. **如何处理并发请求的 Loading？** 用计数器记录请求数量，全部完成才关闭
6. **401 和 403 的区别？** 401 未登录，403 无权限
