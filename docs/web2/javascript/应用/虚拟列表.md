# 虚拟列表

## 为什么需要虚拟列表

当页面需要渲染大量数据（如 10000+ 条）时，全部渲染会导致：
- DOM 节点过多，页面卡顿
- 内存占用过高
- 滚动不流畅

**核心思路：** 只渲染可视区域的数据，非可视区域的用空白占位

## 基础实现

### 固定高度的虚拟列表

每个列表项高度固定，实现最简单

```vue
<template>
  <div class="virtual-list" @scroll="handleScroll" ref="containerRef">
    <!-- 占位容器，撑开总高度 -->
    <div class="phantom" :style="{ height: totalHeight + 'px' }"></div>
    
    <!-- 可视区域 -->
    <div class="list" :style="{ transform: `translateY(${offset}px)` }">
      <div 
        class="item" 
        v-for="item in visibleData" 
        :key="item.id"
        :style="{ height: itemHeight + 'px' }"
      >
        {{ item.content }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  data: Array,      // 全部数据
  itemHeight: {     // 每项高度
    type: Number,
    default: 50
  }
})

const containerRef = ref(null)
const scrollTop = ref(0)

// 容器高度
const containerHeight = ref(600)

// 总高度
const totalHeight = computed(() => props.data.length * props.itemHeight)

// 可视区域可以显示的数量
const visibleCount = computed(() => Math.ceil(containerHeight.value / props.itemHeight))

// 开始索引
const startIndex = computed(() => Math.floor(scrollTop.value / props.itemHeight))

// 结束索引
const endIndex = computed(() => startIndex.value + visibleCount.value)

// 可视区域数据
const visibleData = computed(() => {
  return props.data.slice(startIndex.value, endIndex.value)
})

// 偏移量
const offset = computed(() => startIndex.value * props.itemHeight)

// 滚动事件
const handleScroll = (e) => {
  scrollTop.value = e.target.scrollTop
}
</script>

<style scoped>
.virtual-list {
  height: 600px;
  overflow: auto;
  position: relative;
}

.phantom {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  z-index: -1;
}

.list {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
}
</style>
```

**核心计算：**
```js
// 可视区域能显示多少条
visibleCount = Math.ceil(容器高度 / 每项高度)

// 滚动后，从第几条开始显示
startIndex = Math.floor(滚动距离 / 每项高度)

// 显示到第几条
endIndex = startIndex + visibleCount

// 列表偏移量（让可视数据出现在正确位置）
offset = startIndex * 每项高度
```

## 动态高度的虚拟列表

每个列表项高度不固定，需要缓存每项的高度和位置

```vue
<template>
  <div class="virtual-list" @scroll="handleScroll" ref="containerRef">
    <div class="phantom" :style="{ height: totalHeight + 'px' }"></div>
    
    <div class="list" :style="{ transform: `translateY(${offset}px)` }">
      <div 
        class="item" 
        v-for="item in visibleData" 
        :key="item.id"
        :ref="el => setItemRef(el, item.id)"
      >
        {{ item.content }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, nextTick } from 'vue'

const props = defineProps({
  data: Array,
  estimatedHeight: {  // 预估高度
    type: Number,
    default: 50
  }
})

const containerRef = ref(null)
const scrollTop = ref(0)
const containerHeight = ref(600)

// 缓存每项的位置信息
const positions = ref([])

// 初始化位置信息
const initPositions = () => {
  positions.value = props.data.map((item, index) => ({
    index,
    height: props.estimatedHeight,
    top: index * props.estimatedHeight,
    bottom: (index + 1) * props.estimatedHeight
  }))
}

onMounted(() => {
  initPositions()
})

// 总高度
const totalHeight = computed(() => {
  const len = positions.value.length
  return len > 0 ? positions.value[len - 1].bottom : 0
})

// 二分查找：根据滚动距离找到开始索引
const getStartIndex = (scrollTop) => {
  let left = 0
  let right = positions.value.length - 1
  
  while (left < right) {
    const mid = Math.floor((left + right) / 2)
    if (positions.value[mid].bottom < scrollTop) {
      left = mid + 1
    } else {
      right = mid
    }
  }
  
  return left
}

const startIndex = computed(() => getStartIndex(scrollTop.value))
const visibleCount = computed(() => Math.ceil(containerHeight.value / props.estimatedHeight))
const endIndex = computed(() => Math.min(startIndex.value + visibleCount.value, props.data.length))

const visibleData = computed(() => {
  return props.data.slice(startIndex.value, endIndex.value)
})

const offset = computed(() => {
  return startIndex.value > 0 ? positions.value[startIndex.value].top : 0
})

// 更新位置信息
const updatePositions = () => {
  const nodes = containerRef.value.querySelectorAll('.item')
  
  nodes.forEach((node, index) => {
    const rect = node.getBoundingClientRect()
    const height = rect.height
    const realIndex = startIndex.value + index
    const oldHeight = positions.value[realIndex].height
    const diff = oldHeight - height
    
    // 高度有变化，更新缓存
    if (diff) {
      positions.value[realIndex].height = height
      positions.value[realIndex].bottom = positions.value[realIndex].bottom - diff
      
      // 更新后面所有项的位置
      for (let i = realIndex + 1; i < positions.value.length; i++) {
        positions.value[i].top = positions.value[i - 1].bottom
        positions.value[i].bottom = positions.value[i].bottom - diff
      }
    }
  })
}

const setItemRef = (el, id) => {
  if (el) {
    nextTick(() => {
      updatePositions()
    })
  }
}

const handleScroll = (e) => {
  scrollTop.value = e.target.scrollTop
}
</script>
```

## 优化技巧

### 1. 缓冲区

在可视区域上下多渲染几条，避免快速滚动时出现白屏

```js
const bufferCount = 5  // 上下各多渲染5条

const startIndex = computed(() => {
  const index = getStartIndex(scrollTop.value)
  return Math.max(0, index - bufferCount)
})

const endIndex = computed(() => {
  const index = startIndex.value + visibleCount.value
  return Math.min(props.data.length, index + bufferCount)
})
```

### 2. 节流滚动事件

```js
import { throttle } from 'lodash-es'

const handleScroll = throttle((e) => {
  scrollTop.value = e.target.scrollTop
}, 16)  // 约 60fps
```

### 3. 使用 IntersectionObserver

监听元素是否进入可视区域，更精确

```js
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      // 元素进入可视区域
      loadData(entry.target.dataset.index)
    }
  })
}, {
  root: containerRef.value,
  rootMargin: '100px'  // 提前100px加载
})
```

## 流程总结

1. 计算容器可视区域能显示多少条数据
2. 根据滚动距离计算当前应该显示哪些数据（startIndex、endIndex）
3. 只渲染可视区域的数据，用一个占位元素撑开总高度
4. 通过 `transform: translateY()` 让可视数据出现在正确位置
5. 动态高度需要缓存每项的位置信息，渲染后更新缓存

## 要点

1. **虚拟列表解决什么问题？** 大量数据渲染导致的性能问题
2. **核心原理是什么？** 只渲染可视区域，非可视区域用空白占位
3. **固定高度和动态高度的区别？** 固定高度直接计算，动态高度需要缓存位置信息
4. **如何避免白屏？** 添加缓冲区，上下多渲染几条
5. **如何优化滚动性能？** 节流滚动事件、使用 transform 代替 top
